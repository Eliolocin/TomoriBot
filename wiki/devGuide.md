# For Developers

Document for helping developers contribute to making TomoriBot better as well as better understand how she works.

## Project Overview

TomoriBot is a highly customizable Discord bot powered by Large Language Models (LLMs). Users can personalize her behavior, personality, memory, and language, making her adaptable for both **roleplaying** and **practical use** in community servers thanks to her autonomous tool usage as well.

She is designed to be modular, developer-friendly, and easily deployableâ€”ideal for experimenting with personality-driven AI interaction in social spaces.

### Core Features
- Slash command support
- Server and user-based memory storage
- Personality presets and editing
- Language preference per user
- Admin-only configuration (e.g., model selection, API keys)
- Modular Tool Use and Provider Support
- CI/CD ready and DevOps-aligned project layout

### Target Users
- Discord server owners who want an interactive, helpful, or roleplay-capable AI bot that adapts to server needs/wants
- Users interested in customizing AI personalities for social and community interaction
- Developers and tinkerers experimenting with LLMs, memory systems, and Chatbot UX

## File Structure & Modules

### Tech Stack
- **TypeScript+Zod** for type-checking on compile and runtime
- **Bun** as the runtime and tooling manager
- **Discord.js** for bot-client interaction
- **PostgreSQL** as the primary database
- **LLM API integration** (Google's Gemini only for now)
- **GitHub Actions** for CI/CD pipelines and linting
- **AWS Cloud** for hosting and deployment (soonâ„¢)

### Project Core Structure (Current Modular Architecture)

```
TomoriBot/
â”œâ”€ node_modules/                â† deps â€“ auto-generated by Bun
â”œâ”€ scripts/                     â† one-off maintenance / CLI helpers (run with `bun run`)
â”‚   â”œâ”€ clean-dist.ts            â† wipe build artifacts
â”‚   â”œâ”€ nuke-db.ts               â† drop + recreate dev database
â”‚   â”œâ”€ purge-commands.ts        â† bulk-delete Discord slash commands
â”‚   â””â”€ seed-db.ts               â† run `schema.sql` + `seed.sql`
â””â”€ src/                         â† **everything that ships inside the bot**
    â”œâ”€ commands/                â† slash-command source files (grouped by category)
    â”‚   â”œâ”€ config/              â† `/config â€¦` sub-commands
    â”‚   â”‚   â”œâ”€ setup.ts
    â”‚   â”‚   â””â”€ apikeyset.ts
    â”‚   â”œâ”€ tool/
    â”‚   â”‚   â””â”€ ping.ts
    â”‚   â””â”€ â€¦                    â† more categories to come
    â”œâ”€ db/                      â† SQL that defines & seeds Postgres
    â”‚   â”œâ”€ schema.sql
    â”‚   â””â”€ seed.sql
    â”œâ”€ events/                  â† low-level Discord gateway listeners
    â”‚   â”œâ”€ guildCreate/         â”€â”€ when Tomori joins a server
    â”‚   â”‚   â””â”€ addBot.ts
    â”‚   â”œâ”€ guildMemberAdd/
    â”‚   â”‚   â””â”€ registerUser.ts
    â”‚   â”œâ”€ interactionCreate/
    â”‚   â”‚   â””â”€ handleCommands.ts
    â”‚   â”œâ”€ messageCreate/
    â”‚   â”‚   â”œâ”€ jpTrans.ts
    â”‚   â”‚   â””â”€ tomoriChat.ts    â† **REFACTORED** - now uses modular providers & tools
    â”‚   â””â”€ ready/
    â”‚       â”œâ”€ 01_registerCommands.ts
    â”‚       â””â”€ status.ts
    â”œâ”€ handlers/                â† central dispatcher / shared event utils
    â”‚   â””â”€ eventHandler.ts
    â”œâ”€ locales/                 â† i18n JSON dictionaries (`tool.ping.description` â†’ string)
    â”‚   â”œâ”€ en.ts
    â”‚   â””â”€ ja.json
    â”œâ”€ providers/               â† **MODULAR PROVIDER SYSTEM** - LLM provider abstraction
    â”‚   â””â”€ google/              â† Google Gemini implementation
    â”‚       â”œâ”€ googleProvider.ts      â† implements LLMProvider interface
    â”‚       â”œâ”€ googleStreamAdapter.ts â† streaming logic for Google API
    â”‚       â”œâ”€ googleToolAdapter.ts   â† converts tools to Google format
    â”‚       â””â”€ subAgents.ts           â† Google-specific sub-agents
    â”œâ”€ tools/                   â† **MODULAR TOOL SYSTEM** - provider-agnostic tools
    â”‚   â”œâ”€ toolRegistry.ts      â† central tool registry & execution
    â”‚   â”œâ”€ toolInitializer.ts   â† tool discovery & registration
    â”‚   â”œâ”€ functionCalls/       â† built-in function call tools
    â”‚   â”‚   â”œâ”€ stickerTool.ts   â† Discord sticker selection
    â”‚   â”‚   â”œâ”€ searchTool.ts    â† web search functionality
    â”‚   â”‚   â”œâ”€ memoryTool.ts    â† learning/memory system
    â”‚   â”‚   â””â”€ index.ts         â† tool exports
    â”‚   â””â”€ mcpServers/          â† **FINALIZED** - MCP server integration
    â”‚       â”œâ”€ index.ts         â† unified exports and handler registry
    â”‚       â”œâ”€ brave-search/    â† Brave Search MCP server
    â”‚       â”‚   â”œâ”€ config.json  â† server configuration
    â”‚       â”‚   â””â”€ braveSearchHandler.ts â† behavior handler
    â”‚       â”œâ”€ fetch/           â† Fetch MCP server
    â”‚       â”‚   â”œâ”€ config.json  â† server configuration  
    â”‚       â”‚   â””â”€ fetchHandler.ts â† behavior handler
    â”‚       â””â”€ duckduckgo-search/ â† DuckDuckGo MCP server (ready)
    â”‚           â”œâ”€ config.json  â† server configuration
    â”‚           â””â”€ duckduckgoHandler.ts â† behavior handler
    â”œâ”€ types/                   â† **ORGANIZED TYPE SYSTEM** - domain-specific types
    â”‚   â”œâ”€ ambient/             â† `declare global { â€¦ }`
    â”‚   â”‚   â””â”€ booru.d.ts
    â”‚   â”œâ”€ api/                 â† external API types
    â”‚   â”‚   â””â”€ gemini.ts
    â”‚   â”œâ”€ db/                  â† database schema types
    â”‚   â”‚   â””â”€ schema.ts        â† TS mirror of `schema.sql`
    â”‚   â”œâ”€ discord/             â† Discord-specific types
    â”‚   â”‚   â”œâ”€ embed.ts
    â”‚   â”‚   â”œâ”€ global.ts
    â”‚   â”‚   â””â”€ modal.ts
    â”‚   â”œâ”€ misc/                â† utility types
    â”‚   â”‚   â”œâ”€ context.ts
    â”‚   â”‚   â””â”€ translation.ts
    â”‚   â”œâ”€ provider/            â† provider interface types
    â”‚   â”‚   â””â”€ interfaces.ts
    â”‚   â”œâ”€ stream/              â† **NEW** - streaming system types
    â”‚   â”‚   â”œâ”€ interfaces.ts    â† streaming interfaces
    â”‚   â”‚   â””â”€ types.ts         â† streaming types & constants
    â”‚   â””â”€ tool/                â† **NEW** - tool system types
    â”‚       â”œâ”€ interfaces.ts    â† tool interfaces
    â”‚       â””â”€ mcpTypes.ts      â† **FINALIZED** - comprehensive MCP type definitions
    â”œâ”€ utils/                   â† general-purpose helpers (split by domain)
    â”‚   â”œâ”€ db/
    â”‚   â”‚   â”œâ”€ dbRead.ts
    â”‚   â”‚   â””â”€ dbWrite.ts
    â”‚   â”œâ”€ discord/
    â”‚   â”‚   â”œâ”€ commandLoader.ts
    â”‚   â”‚   â”œâ”€ embedHelper.ts
    â”‚   â”‚   â”œâ”€ eventHelper.ts
    â”‚   â”‚   â”œâ”€ interactionHelper.ts
    â”‚   â”‚   â””â”€ streamOrchestrator.ts â† **NEW** - universal Discord streaming
    â”‚   â”œâ”€ provider/
    â”‚   â”‚   â””â”€ providerFactory.ts   â† dynamic provider selection
    â”‚   â”œâ”€ mcp/                     â† **FINALIZED** - MCP system utilities
    â”‚   â”‚   â”œâ”€ mcpManager.ts        â† server lifecycle management
    â”‚   â”‚   â”œâ”€ mcpExecutor.ts       â† provider-agnostic execution engine
    â”‚   â”‚   â””â”€ mcpConfig.ts         â† configuration management & validation
    â”‚   â”œâ”€ misc/
    â”‚   â”‚   â”œâ”€ boolUtils.ts
    â”‚   â”‚   â”œâ”€ formatSource.ts
    â”‚   â”‚   â”œâ”€ ioHelper.ts
    â”‚   â”‚   â””â”€ logger.ts
    â”‚   â”œâ”€ security/            â† crypto utilities (pgcrypto wrappers, key mgmt)
    â”‚   â”‚   â””â”€ crypto.ts        
    â”‚   â””â”€ text/                â† **ENHANCED** - text processing & streaming
    â”‚      â”œâ”€ contextBuilder.ts â† LLM context assembly
    â”‚      â”œâ”€ localizer.ts      â† i18n support
    â”‚      â””â”€ stringHelper.ts   â† text utilities
    â””â”€ index.ts                 â† entry point â€“ creates Discord client & tool registry
â”œâ”€ .env.example                 â† template env (copy to `.env`)
â”œâ”€ bun.lock                     â† Bun dependency lockfile
â”œâ”€ biome.json                   â† formatter/linter config
â””â”€ README.md                    â† project overview
```

### Key Architectural Changes

**ğŸ—ï¸ Provider Abstraction System**: Complete refactor from Google-locked to modular LLM providers
- `providerFactory` dynamically selects providers based on configuration
- `googleProvider` implements `LLMProvider` interface
- Ready for OpenAI, Anthropic, and future providers

**âš¡ Modular Tool System**: Transformed from 300+ lines of inline code to clean registry
- Tools implement generic `Tool` interface
- `toolRegistry` handles discovery, execution, and permission management
- Provider adapters convert tools to provider-specific formats

**ğŸŒŠ Streaming Modularization**: Universal Discord text streaming logic extracted from provider-specific code
- `streamOrchestrator` handles all Discord integration (600+ lines of reusable logic)
- Provider `streamAdapter`s handle LLM-specific streaming (150-200 lines each)

**ğŸ“ Type Organization**: Logical separation of types by domain
- Stream types in `src/types/stream/`
- Tool types in `src/types/tool/` 
- Provider types in `src/types/provider/`

## Creating New Commands

## Config & Setup Flow

## Database Architecture

## LLM & API Integration

### Provider Architecture Overview

TomoriBot uses a **modular provider architecture** that abstracts LLM interactions behind a common interface. This allows seamless switching between different AI providers while maintaining consistent functionality.

#### Core Provider Interface
```typescript
interface LLMProvider {
    // Provider identification
    getProviderInfo(): ProviderInfo;
    
    // API key validation
    validateApiKey(apiKey: string): Promise<boolean>;
    
    // Configuration creation
    createConfig(tomoriState: TomoriState, apiKey: string): ProviderConfig;
    
    // Tool discovery
    getTools(tomoriState: TomoriState): Tool[];
    
    // Main streaming method
    streamToDiscord(
        channel: BaseGuildTextChannel,
        client: Client, 
        tomoriState: TomoriState,
        config: ProviderConfig,
        contextItems: StructuredContextItem[],
        interaction?: CommandInteraction
    ): Promise<StreamResult>;
}
```

#### Provider Factory Pattern
The `ProviderFactory` namespace provides dynamic provider selection:
```typescript
// Dynamic provider selection based on configuration
const provider = getProviderForTomori(tomoriState);

// Provider-agnostic usage
const config = provider.createConfig(tomoriState, apiKey);
const result = await provider.streamToDiscord(channel, client, tomoriState, config, contextItems);
```

### Current Providers

#### Google Gemini Provider
- **Implementation**: `src/providers/google/googleProvider.ts`
- **Features**: Streaming, function calling, image/video processing
- **Models**: Gemini 2.0 Flash, configurable via environment variables
- **Stream Adapter**: `googleStreamAdapter.ts` handles Gemini-specific streaming logic
- **Tool Adapter**: `googleToolAdapter.ts` converts generic tools to Google format

### Adding New Providers

To add a new LLM provider (e.g., OpenAI, Anthropic):

1. **Create provider implementation**:
```typescript
// src/providers/openai/OpenAIProvider.ts
export class OpenAIProvider extends BaseLLMProvider {
    getProviderInfo(): ProviderInfo {
        return {
            name: "openai",
            version: "1.0", 
            supportsStreaming: true,
            supportsFunctionCalling: true
        };
    }
    
    async validateApiKey(apiKey: string): Promise<boolean> {
        // OpenAI API key validation logic
    }
    
    // ... implement other required methods
}
```

2. **Create stream adapter**:
```typescript
// src/providers/openai/OpenAIStreamAdapter.ts
export class OpenAIStreamAdapter implements StreamProvider {
    async *startStream(config: StreamConfig): AsyncGenerator<RawStreamChunk> {
        // OpenAI streaming implementation
    }
    
    processChunk(chunk: RawStreamChunk): ProcessedChunk {
        // Convert OpenAI chunks to normalized format
    }
}
```

3. **Create tool adapter**:
```typescript
// src/providers/openai/openaiToolAdapter.ts
export class OpenAIToolAdapter implements ToolAdapter {
    convertTool(tool: Tool): OpenAIFunction {
        // Convert generic tool to OpenAI function format
    }
}
```

4. **Register in factory**:
```typescript
// src/providers/ProviderFactory.ts
case "openai":
    return new OpenAIProvider();
```

### Streaming Architecture

TomoriBot uses a **two-layer streaming architecture**:

#### Universal Discord Layer (`streamOrchestrator`)
Handles all Discord-specific logic (600+ lines of reusable code):
- Message creation and editing
- Embed generation and updates 
- Function call routing to `ToolRegistry`
- Stream timeout management
- Error recovery and user notifications
- Message chunking and rate limiting
- Typing simulation and humanization

#### Provider-Specific Layer (`StreamAdapter`)
Handles LLM-specific streaming (150-200 lines per provider):
- API client management
- Chunk processing and normalization
- Provider-specific error handling

### Tool System Integration

All providers use the same **modular tool system**:

#### Tool Registry
```typescript
// Tools are automatically discovered and registered at startup
const availableTools = ToolRegistry.getAvailableTools(providerName, context);

// Tools are executed uniformly regardless of provider
const result = await ToolRegistry.executeTool(toolName, args, context);
```

#### Provider Tool Adapters
Each provider has an adapter that converts generic tools to provider-specific formats:
```typescript
// Google format conversion
const googleTools = googleToolAdapter.convertToolsArray(genericTools);

// Future: OpenAI format conversion  
const openaiTools = openaiToolAdapter.convertToolsArray(genericTools);
```

### Adding New Tools

TomoriBot's modular tool system makes adding new functionality straightforward:

#### Built-in Function Call Tools

1. **Create tool implementation**:
```typescript
// src/tools/functionCalls/yourTool.ts
export class YourTool extends BaseTool {
    name = "your_tool_name";
    description = "What your tool does";
    category = "utility" as const;
    
    parameters: ToolParameterSchema = {
        type: "object",
        properties: {
            param1: { type: "string", description: "Parameter description" }
        },
        required: ["param1"]
    };
    
    async execute(args: Record<string, unknown>, context: ToolContext): Promise<ToolResult> {
        // Your tool logic here
        return { success: true, data: { status: "completed" } };
    }
}
```

2. **Export in index**:
```typescript
// src/tools/functionCalls/index.ts
export { YourTool } from "./yourTool";
```

3. **Automatic integration**: The system automatically:
   - Discovers your tool via dynamic imports
   - Converts your schema to provider-specific formats
   - Handles execution through the registry
   - Manages permissions and feature flags

#### MCP Server Tools (Fully Finalized & Production-Ready)

**Model Context Protocol (MCP)** integration is **completely finalized** with provider-agnostic architecture, full type safety, and zero technical debt! MCP servers provide standardized access to external data sources and functionality through TomoriBot's modular tool architecture.

**ğŸ‰ Finalized MCP Architecture:**

**1. Modular MCP System** - Complete provider-agnostic architecture:
- **MCP Manager** (`src/utils/mcp/mcpManager.ts`) - Server lifecycle management
- **MCP Executor** (`src/utils/mcp/mcpExecutor.ts`) - Universal function execution with behavior handler registry
- **MCP Config Manager** (`src/utils/mcp/mcpConfig.ts`) - JSON configuration loading and validation
- **MCP Type Definitions** (`src/types/tool/mcpTypes.ts`) - Comprehensive TypeScript interfaces (zero `any` types)

**2. Server-Specific Behavior Handlers** - Dedicated logic per MCP server:
- **Brave Search Handler** (`src/tools/mcpServers/brave-search/braveSearchHandler.ts`) - Image auto-sending, parameter overrides, web search enhancements
- **Fetch Handler** (`src/tools/mcpServers/fetch/fetchHandler.ts`) - URL content processing and markdown conversion
- **DuckDuckGo Handler** (`src/tools/mcpServers/duckduckgo-search/duckduckgoHandler.ts`) - Future free web search (scaffolded)

**3. Universal Provider Integration:**
```typescript
// Works identically across Google, OpenAI, Anthropic (future)
interface MCPCapableToolAdapter {
    convertTool(tool: Tool): ProviderSpecificTool;
    executeMCPFunction(functionName: string, args: Record<string, unknown>, context?: ToolContext): Promise<TypedMCPToolResult>;
}
```

**4. Server Configuration** (`src/tools/mcpServers/{server-name}/config.json`):
```json
{
  "name": "brave-search",
  "displayName": "Brave Search",
  "npmPackage": "@brave/brave-search-mcp-server",
  "description": "Premium web search with image/video/news search",
  "requiredEnvVars": ["BRAVE_API_KEY"],
  "category": "search",
  "transport": "stdio",
  "enabled": true
}
```

**5. Database Integration** - Encrypted API key storage per guild:
```sql
CREATE TABLE mcp_api_keys (
  mcp_api_key_id SERIAL PRIMARY KEY,
  server_id INT NOT NULL,
  mcp_name TEXT NOT NULL,
  api_key BYTEA,  -- Encrypted using pgcrypto
  UNIQUE (server_id, mcp_name)
);
```

**6. Unified Tool Execution** - Same interface as built-in tools:
```typescript
// MCP tools execute through the same registry as built-in tools
const result = await ToolRegistry.executeTool(toolName, args, context);
```

**ğŸš€ Available MCP Servers:**
- âœ… **Brave Search MCP** - Premium web search with automatic image sending to Discord, enhanced with fetch reminders
- âœ… **Fetch MCP** - URL content retrieval and markdown conversion with content length optimization
- ğŸ”„ **DuckDuckGo Search MCP** - Free web search alternative (handler ready, awaiting server availability)

**ğŸ¯ Key Architecture Benefits:**
- **Zero Technical Debt** - No `any` types, comprehensive error handling, perfect code quality
- **Provider Agnostic** - Works identically across Google, OpenAI, Anthropic providers
- **Easily Extensible** - New MCP servers can be added with minimal code (~100 lines per server)
- **Type Safe** - Full TypeScript compliance with comprehensive interface definitions
- **Performance Optimized** - Efficient parameter overrides, result processing, and resource management

### Current Tool Implementations

**Built-in Function Call Tools:**
- **StickerTool**: Discord sticker selection and sending
- **MemoryTool**: Learning and memory storage (personal and server-wide)

**ğŸ¯ Production-Ready MCP Server Tools:**
- **Brave Search Functions** (Handler: `braveSearchHandler.ts`):
  - `brave_web_search` - Enhanced web search with fetch capability reminders
  - `brave_image_search` - Automatic image sending to Discord with cleaned responses
  - `brave_video_search` - Video search with metadata
  - `brave_news_search` - Real-time news search
  - `brave_local_search` - Location-based business search
  - `brave_summarizer` - AI-powered content summarization

- **Fetch Functions** (Handler: `fetchHandler.ts`):
  - `fetch` - URL content retrieval with markdown conversion and length optimization

- **ğŸ”„ Ready for Integration MCP Tools:**
  - **DuckDuckGo Search** (Handler: `duckduckgoHandler.ts` - scaffolded)
  - **Community MCP Servers** - Framework ready for third-party integration

## Message Generation/Tool Call Flow

### Complete Message Processing Architecture

When a user sends a message that triggers TomoriBot, the following modular flow executes:

#### Phase 1: Discord Validation & Context (Provider-Agnostic)
```
User Message â†’ Discord Event â†’ tomoriChat.ts
â”œâ”€â”€ 1. Channel & Permission Validation
â”œâ”€â”€ 2. Semaphore Lock Acquisition  
â”œâ”€â”€ 3. Tomori State & User Data Loading
â”œâ”€â”€ 4. Message History Fetching
â”œâ”€â”€ 5. Context Assembly (contextBuilder.ts)
â””â”€â”€ 6. Trigger Word & Auto-Counter Logic
```

#### Phase 2: Provider Selection & Configuration
```
7. Provider Factory â†’ Dynamic Provider Selection
   â”œâ”€â”€ getProviderForTomori(tomoriState)
   â”œâ”€â”€ provider.createConfig(tomoriState, apiKey)
   â”œâ”€â”€ provider.getTools(tomoriState)
   â””â”€â”€ Tool Format Conversion (via ToolAdapter)
```

#### Phase 3: Streaming & Tool Execution
```
8. StreamOrchestrator.streamToDiscord(provider, config, context)
   â”œâ”€â”€ Provider StreamAdapter â†’ LLM API Streaming
   â”œâ”€â”€ Chunk Processing â†’ ProcessedChunk normalization
   â””â”€â”€ Function Call Detection

9. Tool Execution Loop (if function calls detected)
   â”œâ”€â”€ ToolRegistry.executeTool(toolName, args, context)
   â”œâ”€â”€ Tool Implementation Execution
   â”œâ”€â”€ Result Formatting & Discord Integration
   â””â”€â”€ Function Result â†’ Back to LLM

10. Response Completion
    â”œâ”€â”€ Final Text Streaming to Discord
    â”œâ”€â”€ Sticker Sending (if selected)
    â””â”€â”€ Semaphore Release
```

### Key Architectural Benefits

**ğŸ”„ Single Entry Point**: All tool execution flows through `ToolRegistry.executeTool()`

**ğŸ¯ Provider Agnostic**: Same message flow works with Google, OpenAI, Anthropic

**âš¡ Modular Tools**: Tools can be added/removed without changing core flow

**ğŸ›¡ï¸ Error Resilience**: Comprehensive error handling at every layer

**ğŸ“Š Consistent Behavior**: Universal timeout, rate limiting, and Discord integration

### Example: Memory Tool Execution

User: `"Tomori, remember I like pizza ğŸ•"`

1. **Provider Selection**: `GoogleProvider` selected based on configuration
2. **Tool Discovery**: `MemoryTool` available and converted to Google format
3. **LLM Decision**: Gemini decides to call `remember_this_fact` function
4. **Tool Execution**: `ToolRegistry.executeTool("remember_this_fact", args, context)`
5. **Memory Storage**: `MemoryTool.execute()` saves to database via `addPersonalMemoryByTomori()`
6. **Result Integration**: Success result sent back to Gemini
7. **Response Generation**: "Great! I've learned that you like pizza ğŸ•"

This same flow works identically with any LLM provider - the modular architecture ensures consistent behavior across all providers.

## Deployment & CI/CD

## Contributing Guidelines

### Development Workflow

1. **File Naming Convention**: Use camelCase for all file names
2. **Type Organization**: Place types and interfaces in appropriate `src/types/` subdirectories
3. **Provider Development**: Follow the provider interface pattern
4. **Tool Development**: Extend `BaseTool` and implement required methods
5. **Testing**: Use `bun run check` for TypeScript errors and `bun run lint` for Biome linting
6. **Code Quality**: Biome handles formatting and linting automatically

### Architecture Principles

- **Modularity**: New features should use the modular tool/provider systems
- **Provider Agnostic**: Avoid hardcoding specific LLM provider logic in core files
- **Type Safety**: All interfaces should be properly typed with Zod validation
- **Error Handling**: Comprehensive error logging with context
- **Documentation**: JSDoc comments for all public functions
